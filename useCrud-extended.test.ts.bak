import { createStoreRegistry } from '../createStoreRegistry';
import { useCrud, callIfFunc } from '../useCrud';
import { renderHook, act, waitFor } from '@testing-library/react';

// Create a proper axios function mock with all necessary properties
const mockAxios = jest.fn();
Object.assign(mockAxios, {
  get: jest.fn(),
  post: jest.fn(),
  patch: jest.fn(),
  put: jest.fn(),
  delete: jest.fn(),
  create: jest.fn(),
  defaults: {},
  interceptors: {
    request: { use: jest.fn(), eject: jest.fn() },
    response: { use: jest.fn(), eject: jest.fn() }
  }
});

interface TestUser {
  id: number;
  name: string;
  email: string;
}

describe('useCrud - Extended Coverage Tests', () => {
  let getOrCreateStore: any;
  let store: any;

  beforeEach(() => {
    jest.clearAllMocks();
    mockAxios.mockClear();
    
    getOrCreateStore = createStoreRegistry<{
      users: TestUser;
    }>();

    store = getOrCreateStore('users', {
      axios: mockAxios,
      route: '/users',
      actions: {
        getList: true,
        get: true,
        create: true,
        update: true,
        delete: true,
      },
    });
  });

  describe('callIfFunc utility', () => {
    it('should call function when provided', () => {
      const mockFn = jest.fn();
      callIfFunc(mockFn, 'arg1', 'arg2');
      expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
    });

    it('should not throw when non-function is provided', () => {
      expect(() => callIfFunc(null)).not.toThrow();
      expect(() => callIfFunc(undefined)).not.toThrow();
      expect(() => callIfFunc('not a function')).not.toThrow();
      expect(() => callIfFunc(123)).not.toThrow();
    });
  });

  describe('Action execution - success scenarios', () => {
    it('should execute getList action successfully', async () => {
      const mockUsers = [
        { id: 1, name: 'John', email: 'john@test.com' },
        { id: 2, name: 'Jane', email: 'jane@test.com' }
      ];

      mockAxios.mockResolvedValueOnce({
        data: mockUsers
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.getList();
      });

      await waitFor(() => {
        expect(mockAxios).toHaveBeenCalledWith({
          method: 'get',
          url: '/users',
          params: undefined
        });
      });

      expect(result.current.list).toEqual(mockUsers);
      expect(result.current.count).toBe(2);
    });

    it('should execute getList with paginated response', async () => {
      const mockUsers = [
        { id: 1, name: 'John', email: 'john@test.com' }
      ];

      mockAxios.mockResolvedValueOnce({
        data: {
          results: mockUsers,
          count: 10
        }
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.getList();
      });

      expect(result.current.list).toEqual(mockUsers);
      expect(result.current.count).toBe(10);
    });

    it('should execute get action successfully', async () => {
      const mockUser = { id: 1, name: 'John', email: 'john@test.com' };

      mockAxios.mockResolvedValueOnce({
        data: mockUser
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.get(mockUser);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'get',
        url: '/users/1',
        params: undefined,
        data: mockUser
      });

      expect(result.current.list).toEqual([mockUser]);
    });

    it('should execute create action successfully', async () => {
      const newUser = { name: 'New User', email: 'new@test.com' };
      const createdUser = { id: 3, ...newUser };

      mockAxios.mockResolvedValueOnce({
        data: createdUser
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.create(newUser);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'post',
        url: '/users',
        params: undefined,
        data: newUser
      });

      expect(result.current.list).toEqual([createdUser]);
    });

    it('should execute update action successfully', async () => {
      const existingUser = { id: 1, name: 'Old Name', email: 'old@test.com' };
      const updatedUser = { id: 1, name: 'Updated Name', email: 'updated@test.com' };

      // First set an existing user
      act(() => {
        const state = store.getState();
        state.setInstance(existingUser);
      });

      mockAxios.mockResolvedValueOnce({
        data: updatedUser
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.update(updatedUser);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'patch',
        url: '/users/1',
        params: undefined,
        data: updatedUser
      });
    });

    it('should execute delete action successfully', async () => {
      const userToDelete = { id: 1, name: 'John', email: 'john@test.com' };

      // First set an existing user
      act(() => {
        const state = store.getState();
        state.setInstance(userToDelete);
      });

      mockAxios.mockResolvedValueOnce({
        data: {}
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.delete(userToDelete);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'delete',
        url: '/users/1',
        params: undefined,
        data: userToDelete
      });

      expect(result.current.list).toEqual([]);
    });
  });

  describe('Action execution - with callbacks and options', () => {
    it('should handle action with params and callback', async () => {
      const mockUsers = [{ id: 1, name: 'John', email: 'john@test.com' }];
      const mockCallback = jest.fn();

      mockAxios.mockResolvedValueOnce({
        data: mockUsers
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.getList({
          params: { page: 1, limit: 10 },
          callback: mockCallback
        });
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'get',
        url: '/users',
        params: { page: 1, limit: 10 }
      });

      expect(mockCallback).toHaveBeenCalledWith(mockUsers);
    });

    it('should handle action with axiosConfig', async () => {
      const mockUsers = [{ id: 1, name: 'John', email: 'john@test.com' }];

      mockAxios.mockResolvedValueOnce({
        data: mockUsers
      });

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.getList({
          axiosConfig: { timeout: 5000 }
        });
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'get',
        url: '/users',
        params: undefined,
        timeout: 5000
      });
    });

    it('should handle onResponse callback', async () => {
      const mockUsers = [{ id: 1, name: 'John', email: 'john@test.com' }];
      const mockOnResponse = jest.fn();

      mockAxios.mockResolvedValueOnce({
        data: mockUsers
      });

      const { result } = renderHook(() => useCrud(store));

      act(() => {
        result.current.getList.onResponse = mockOnResponse;
      });

      await act(async () => {
        await result.current.getList();
      });

      expect(mockOnResponse).toHaveBeenCalledWith(mockUsers);
    });
  });

  describe('Action execution - error scenarios', () => {
    it('should handle action errors gracefully', async () => {
      const mockError = new Error('Network error');
      const mockOnError = jest.fn();

      mockAxios.mockRejectedValueOnce(mockError);

      const { result } = renderHook(() => useCrud(store));

      await act(async () => {
        await result.current.getList({
          onError: mockOnError
        });
      });

      expect(mockOnError).toHaveBeenCalledWith(mockError);
      expect(result.current.getList.error).toBe(mockError);
    });

    it('should prevent concurrent requests', async () => {
      const mockUsers = [{ id: 1, name: 'John', email: 'john@test.com' }];

      // Set up a delayed response
      mockAxios.mockImplementation(() => 
        new Promise(resolve => 
          setTimeout(() => resolve({ data: mockUsers }), 100)
        )
      );

      const { result } = renderHook(() => useCrud(store));

      // Set loading state to simulate ongoing request
      act(() => {
        const state = store.getState();
        state.setLoadingState('getList', { isLoading: true });
      });

      // Try to call the action while loading
      await act(async () => {
        const result1 = result.current.getList();
        expect(result1).toBeUndefined(); // Should return early
      });
    });
  });

  describe('Custom actions with function routes', () => {
    it('should handle function routes correctly', async () => {
      const storeWithFunctionRoute = getOrCreateStore('functionRouteUsers', {
        axios: mockAxios,
        route: (data: any) => `/users/${data.id}/profile`,
        actions: { get: true }
      });

      const mockUser = { id: 5, name: 'Function Route User' };

      mockAxios.mockResolvedValueOnce({
        data: mockUser
      });

      const { result } = renderHook(() => useCrud(storeWithFunctionRoute));

      await act(async () => {
        await result.current.get(mockUser);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'get',
        url: '/users/5/profile',
        params: undefined,
        data: mockUser
      });
    });
  });

  describe('Custom actions', () => {
    it('should execute custom actions', async () => {
      const storeWithCustomActions = getOrCreateStore('customActionUsers', {
        axios: mockAxios,
        route: '/users',
        actions: { getList: true },
        customActions: {
          activate: {
            route: (user: TestUser) => `/users/${user.id}/activate`,
            method: 'post',
          }
        }
      });

      const user = { id: 1, name: 'John', email: 'john@test.com' };
      
      mockAxios.mockResolvedValueOnce({
        data: { ...user, active: true }
      });

      const { result } = renderHook(() => useCrud(storeWithCustomActions));

      await act(async () => {
        await result.current.activate(user);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'post',
        url: '/users/1/activate',
        params: undefined,
        data: user
      });
    });
  });

  describe('Action configuration with prepare function', () => {
    it('should use prepare function when provided', async () => {
      const storeWithPrepare = getOrCreateStore('prepareUsers', {
        axios: mockAxios,
        route: '/users',
        actions: { 
          create: {
            prepare: (data: any) => ({ ...data, timestamp: '2023-01-01' })
          }
        }
      });

      const newUser = { name: 'Test User', email: 'test@test.com' };
      const preparedUser = { ...newUser, timestamp: '2023-01-01' };

      mockAxios.mockResolvedValueOnce({
        data: { id: 1, ...preparedUser }
      });

      const { result } = renderHook(() => useCrud(storeWithPrepare));

      await act(async () => {
        await result.current.create(newUser);
      });

      expect(mockAxios).toHaveBeenCalledWith({
        method: 'post',
        url: '/users',
        params: undefined,
        data: preparedUser
      });
    });
  });

  describe('Action configuration with multiple callbacks', () => {
    it('should call action callback, onResponse, and provided callback', async () => {
      const actionCallback = jest.fn();
      const onResponseCallback = jest.fn();
      const providedCallback = jest.fn();

      const storeWithCallbacks = getOrCreateStore('callbackUsers', {
        axios: mockAxios,
        route: '/users',
        actions: { 
          getList: {
            callback: actionCallback
          }
        }
      });

      const mockUsers = [{ id: 1, name: 'John', email: 'john@test.com' }];

      mockAxios.mockResolvedValueOnce({
        data: mockUsers
      });

      const { result } = renderHook(() => useCrud(storeWithCallbacks));

      // Set onResponse callback
      act(() => {
        result.current.getList.onResponse = onResponseCallback;
      });

      await act(async () => {
        await result.current.getList({
          callback: providedCallback
        });
      });

      expect(actionCallback).toHaveBeenCalledWith(mockUsers);
      expect(onResponseCallback).toHaveBeenCalledWith(mockUsers);
      expect(providedCallback).toHaveBeenCalledWith(mockUsers);
    });
  });
});
